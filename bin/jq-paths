#!/usr/bin/env zsh
# path logic inspired by https://github.com/stedolan/jq/issues/243
JQ_REPL_JQ="${JQ_REPL_JQ:-jq}"
[[ $(print -rl -- ${(t)JQ_REPL_JQ}) =~ scalar* ]] && export JQ_REPL_JQ=( ${=JQ_REPL_JQ} )

filter="${1:-.}"

# JQ_PATHS_ARGS has to be unquoted so it's passed as cli args to jq so
# word splitting is desirable here
# shellcheck disable=SC2086
$JQ_REPL_JQ[@] ${JQ_PATHS_ARGS:-} "${filter}" |\
$JQ_REPL_JQ[@] ${JQ_PATHS_ARGS:-} --arg filter "${filter}" --slurp --raw-output '
def format_path($path):
  $path |
  if type == "string" then
    # use generic object index syntax if key contains non-alphanumeric characters or starts with a digit
    if test("(^[0-9])|[^a-zA-Z0-9_]") then 
      "[\"\(.)\"]"
    else
      ".\(.)"
    end
  elif type == "number" then 
    "[]"
  else 
    error 
  end
;

def format_path: format_path(.);

[
  path(..)  |
  reduce .[] as $item (""; . + format_path($item))
] | sort | unique | .[] | $filter + .
'

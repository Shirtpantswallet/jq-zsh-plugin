#!/usr/bin/env zsh
#
# if 1st arg is '-' read from stdin
# if 1st arg is '--' take the command after it verbatim and execute it to get the input
# if 1st arg is anything else, treat it as a file
set -eu

JQ_REPL_JQ="${JQ_REPL_JQ:-jq}"
[[ $(print -rl -- ${(t)JQ_REPL_JQ}) =~ scalar* ]] && export JQ_REPL_JQ=( ${=JQ_REPL_JQ} )

# Build the jq-paths command with optional bkt caching
# Uses file modification time for cache invalidation
build_jq_paths_cmd() {
  local input_file="$1"
  if [[ "${JQ_PATHS_CACHE:-1}" == "1" ]] && command -v bkt > /dev/null 2>&1; then
    echo "bkt --ttl=${JQ_PATHS_CACHE_TTL:-5m} --modtime=\"$input_file\" --discard-failures -- jq-paths < \"$input_file\""
  else
    echo "jq-paths < \"$input_file\""
  fi
}

if [ -n "${1:-}" ] && [ "$1" != "-" ] && [ "$1" != "--" ]; then
  input="$1"
  output=$(mktemp)
  error_file="${output}.err"
  reload_script=$(mktemp)
  completions_wrapper=$(mktemp)
  trap 'rm -f "$output" "$error_file" "$reload_script" "$completions_wrapper"' EXIT
else
  input=$(mktemp)
  output=$(mktemp)
  error_file="${output}.err"
  reload_script=$(mktemp)
  completions_wrapper=$(mktemp)
  trap 'rm -f "$input" "$output" "$error_file" "$reload_script" "$completions_wrapper"' EXIT
fi

# Initialize error file
: > "$error_file"

if [ -z "${1:-}" ] || [ "$1" = "-" ]; then
  cat /dev/stdin >"$input"
fi
# Path to scripts (same directory as this script)
script_dir="${0:A:h}"
builtins_file="$script_dir/jq-builtins"
completions_script="$script_dir/jq-completions"

# Build the jq-paths command (with or without bkt caching)
jq_paths_cmd=$(build_jq_paths_cmd "$input")

# Command to reload input data (for --mode)
if [ "${1:-}" = "--" ]; then
  shift
  export FZF_JQ_RELOAD_INPUT="$* > $input"
else
  export FZF_JQ_RELOAD_INPUT=""
fi

# Build reload script (re-runs input command if any, then paths + builtins)
{
  echo "#!/usr/bin/env zsh"
  [[ -n "$FZF_JQ_RELOAD_INPUT" ]] && echo "$FZF_JQ_RELOAD_INPUT"
  echo "$jq_paths_cmd"
  echo "\"$builtins_file\" 2>/dev/null"
} > "$reload_script"
chmod +x "$reload_script"

# Build completions wrapper script (takes query as $1)
# Falls back to simple mode if jq-completions doesn't exist
{
  echo "#!/usr/bin/env zsh"
  if [[ -x "$completions_script" ]]; then
    echo "\"$completions_script\" \"\$1\" \"$input\" \"$builtins_file\" '$jq_paths_cmd'"
  else
    echo "$jq_paths_cmd"
    echo "\"$builtins_file\" 2>/dev/null"
  fi
} > "$completions_wrapper"
chmod +x "$completions_wrapper"

# default ignore
FZF_COPY_TO_CLIPBOARD="execute-silent(ignore)"

# other platforms can be supported here as needed
command -v xclip > /dev/null && \
  FZF_COPY_TO_CLIPBOARD="execute-silent(echo -n {} | xclip -in -sel clip)+abort"

# Script to get error label (empty if no error, error message if present)
get_error_label="if [[ -s ${(q)error_file} ]]; then printf '‚ùå %s' \"\$(cat ${(q)error_file})\"; fi"

# TODO: add ability to modify jq args dynamically. This may have ripple effects on the output of `jq-paths`.
"$reload_script" |
  fzf \
    --preview "jq-repl-preview {q} ${(q)input} ${(q)output}" \
    --preview-window="down:90%:border-top" \
    --preview-label="" \
    --preview-label-pos="bottom" \
    --height="99%" \
    --query="." \
    --bind "tab:replace-query+first,return:print-query" \
    --bind "ctrl-p:preview-up,ctrl-n:preview-down" \
    --bind "ctrl-alt-p:preview-half-page-up,ctrl-alt-n:preview-half-page-down" \
    --bind "shift-up:preview-up,shift-down:preview-down" \
    --bind "alt-up:preview-page-up,alt-down:preview-page-down" \
    --bind "ctrl-y:$FZF_COPY_TO_CLIPBOARD" \
    --bind "ctrl-r:reload($reload_script)+refresh-preview" \
    --bind "change:reload($completions_wrapper {q})+refresh-preview+transform-preview-label($get_error_label)"
